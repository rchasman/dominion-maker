import type { GameState } from "../types/game-state";
import type { GameCommand, CommandResult } from "./types";
import type { PlayerId } from "../events/types";
import { handleSubmitDecision } from "./handle-decision";
import {
  handlePlayAction,
  handlePlayTreasure,
  handlePlayAllTreasures,
  handleUnplayTreasure,
  handleBuyCard,
} from "./handle-actions";
import {
  handleStartGame,
  handleEndPhase,
  handleRequestUndo,
} from "./handle-flow";

/**
 * Calculate the effective cost of a card considering active effects.
 * Returns base cost, modified cost, and list of applied modifiers.
 * @internal - Only used by command handler for affordability validation
 */
function calculateEffectiveCost(
  state: GameState,
  card: CardName,
): {
  baseCost: number;
  modifiedCost: number;
  modifiers: Array<{ source: CardName; delta: number }>;
} {
  const baseCost = CARDS[card].cost;
  const modifiers = state.activeEffects
    .filter(e => e.effectType === "cost_reduction")
    .map(e => ({ source: e.source, delta: -e.parameters.amount }));

  const modifiedCost = Math.max(
    0,
    baseCost + modifiers.reduce((sum, m) => sum + m.delta, 0),
  );

  return { baseCost, modifiedCost, modifiers };
}

/**
 * Process triggers from cards in play for a given trigger type.
 * Returns events generated by matching triggers.
 */
function processTriggers(
  state: GameState,
  player: PlayerId,
  triggerType: TriggerType,
  context: TriggerContext,
): GameEvent[] {
  const playerState = state.players[player];
  if (!playerState) return [];

  return playerState.inPlay.flatMap(inPlayCard => {
    const triggers = CARDS[inPlayCard].triggers;
    if (!triggers) return [];

    return triggers
      .filter(t => t.on === triggerType)
      .filter(t => !t.condition || t.condition(context))
      .flatMap(t => t.effect(context));
  });
}

/**
 * Handle a command and return the resulting events.
 * Validates the command against current state before producing events.
 */
export function handleCommand(
  state: GameState,
  command: GameCommand,
  fromPlayer?: PlayerId,
): CommandResult {
  // Validate player turn (unless it's a decision response or undo)
  if (fromPlayer && !isValidPlayer(state, command, fromPlayer)) {
    return { ok: false, error: "Not your turn" };
  }

  switch (command.type) {
    case "START_GAME":
      return handleStartGame(
        state,
        command.players,
        command.kingdomCards,
        command.seed,
      );

    case "PLAY_ACTION":
      return handlePlayAction(state, command.player, command.card);

    case "PLAY_TREASURE":
      return handlePlayTreasure(state, command.player, command.card);

    case "PLAY_ALL_TREASURES":
      return handlePlayAllTreasures(state, command.player);

    case "UNPLAY_TREASURE":
      return handleUnplayTreasure(state, command.player, command.card);

    case "BUY_CARD":
      return handleBuyCard(state, command.player, command.card);

    case "END_PHASE":
      return handleEndPhase(state, command.player);

    case "SUBMIT_DECISION":
      return handleSubmitDecision(state, command.player, command.choice);

    case "REQUEST_UNDO":
      return handleRequestUndo(
        state,
        command.player,
        command.toEventId,
        command.reason,
      );

    case "APPROVE_UNDO":
    case "DENY_UNDO":
      // These are handled by the engine, not here
      return { ok: false, error: "Undo approval handled by engine" };

    default: {
      const _exhaustive: never = command;
      void _exhaustive;
      return { ok: false, error: "Unknown command type" };
    }
  }
}

/**
 * Check if a player can issue this command.
 */
function isValidPlayer(
  state: GameState,
  command: GameCommand,
  fromPlayer: PlayerId,
): boolean {
  // Decision responses can come from the decision's player
  if (command.type === "SUBMIT_DECISION") {
    return state.pendingDecision?.player === fromPlayer;
  }

  // Undo requests can come from any player
  if (
    command.type === "REQUEST_UNDO" ||
    command.type === "APPROVE_UNDO" ||
    command.type === "DENY_UNDO"
  ) {
    return true;
  }

  // Other commands must come from active player
  return state.activePlayer === fromPlayer;
}

// ============================================
// COMMAND HANDLERS
// ============================================

function handleStartGame(
  _state: GameState,
  players: PlayerId[],
  kingdomCards?: CardName[],
  seed?: number,
): CommandResult {
  // Select kingdom cards if not provided
  const selectedKingdom = kingdomCards || selectRandomKingdomCards();

  // Calculate supply based on player count
  const supply = calculateSupply(players.length, selectedKingdom);

  // Root cause - initializing game
  const rootEventId = generateEventId();
  const events: GameEvent[] = [
    {
      type: "GAME_INITIALIZED",
      players,
      kingdomCards: selectedKingdom,
      supply,
      seed,
      id: rootEventId,
    },
  ];

  // Deal starting decks (7 Copper, 3 Estate)
  const startingDeck: CardName[] = [
    "Copper",
    "Copper",
    "Copper",
    "Copper",
    "Copper",
    "Copper",
    "Copper",
    "Estate",
    "Estate",
    "Estate",
  ];

  const playerSetupEvents = players.flatMap(player => {
    const shuffledDeck = shuffle([...startingDeck]);
    const initialHand = shuffledDeck.slice(-GAME_CONSTANTS.INITIAL_HAND_SIZE);
    return [
      {
        type: "INITIAL_DECK_DEALT" as const,
        player,
        cards: shuffledDeck,
        id: generateEventId(),
        causedBy: rootEventId,
      },
      {
        type: "INITIAL_HAND_DRAWN" as const,
        player,
        cards: initialHand,
        id: generateEventId(),
        causedBy: rootEventId,
      },
    ];
  });

  // Start turn 1
  const turnStartId = generateEventId();

  // Add initial resources as explicit events for log clarity
  return {
    ok: true,
    events: [
      ...events,
      ...playerSetupEvents,
      {
        type: "TURN_STARTED",
        turn: 1,
        player: players[0],
        id: turnStartId,
      },
      ...createResourceEvents(
        [
          { type: "ACTIONS_MODIFIED", delta: 1 },
          { type: "BUYS_MODIFIED", delta: 1 },
        ],
        turnStartId,
      ),
    ],
  };
}

function handlePlayAction(
  state: GameState,
  player: PlayerId,
  card: CardName,
): CommandResult {
  // Validate using middleware
  const validationError = validateCommand(
    () => validators.phase(state, "action"),
    () => validators.hasActions(state),
    () => validators.isAction(card),
    () => validators.playerExists(state, player),
    () => validators.cardInHand(state, player, card),
  );
  if (validationError) {
    return validationError;
  }

  // Root cause event - playing the card
  const rootEventId = generateEventId();
  const baseEvents: GameEvent[] = [
    {
      type: "CARD_PLAYED",
      player: player,
      card,
      id: rootEventId,
    },
    ...createResourceEvents(
      [{ type: "ACTIONS_MODIFIED", delta: -1 }],
      rootEventId,
    ),
  ];

  // Apply these events to get intermediate state
  const midState = applyEvents(state, baseEvents);

  // Execute card effect
  const effect = getCardEffect(card);
  if (effect) {
    // Check if this is an attack card (auto-handle reactions)
    const cardDef = CARDS[card];
    const isAttackCard = cardDef?.types.includes("attack");

    if (isAttackCard) {
      // Delegate to centralized attack orchestration
      const attackEvents = orchestrateAttack({
        state: midState,
        attacker: player,
        attackCard: card,
        effect,
        rootEventId,
      });
      return { ok: true, events: [...baseEvents, ...attackEvents] };
    }

    // Not an attack card, call effect normally
    const result = effect({
      state: midState,
      player,
      card,
    });

    const linkedEffectEvents = result.events.map(e => ({
      ...e,
      id: generateEventId(),
      causedBy: rootEventId,
    }));

    // Handle normal decision if present
    const decisionEvent = result.pendingDecision
      ? [
          {
            type: "DECISION_REQUIRED" as const,
            decision: {
              ...result.pendingDecision,
              cardBeingPlayed: card,
              metadata: {
                ...result.pendingDecision.metadata,
                originalCause: rootEventId, // Store original PLAY_ACTION event ID for causality chain
              },
            },
            id: generateEventId(),
            causedBy: rootEventId,
          },
        ]
      : [];

    return {
      ok: true,
      events: [...baseEvents, ...linkedEffectEvents, ...decisionEvent],
    };
  }

  return { ok: true, events: baseEvents };
}

function handlePlayTreasure(
  state: GameState,
  player: PlayerId,
  card: CardName,
): CommandResult {
  // Validate using middleware
  const validationError = validateCommand(
    () => validators.phase(state, "buy"),
    () => validators.isTreasure(card),
    () => validators.playerExists(state, player),
    () => validators.cardInHand(state, player, card),
  );
  if (validationError) {
    return validationError;
  }

  const playerState = state.players[player];

  // Root cause event - playing the treasure
  const rootEventId = generateEventId();
  const baseEvents: GameEvent[] = [
    {
      type: "CARD_PLAYED",
      player: player,
      card,
      id: rootEventId,
    },
  ];

  // Add coins - caused by playing the treasure
  const coins = CARDS[card].coins || 0;
  const coinEvents =
    coins > 0
      ? createResourceEvents([{ type: "COINS_MODIFIED", delta: coins }], rootEventId)
      : [];

  // Check for treasure triggers from cards in play
  const treasuresInPlay = playerState.inPlay.filter(c =>
    CARDS[c].types.includes("treasure"),
  );
  const isFirstOfType = !treasuresInPlay.includes(card);

  const triggerEvents = processTriggers(state, player, "treasure_played", {
    card,
    isFirstOfType,
    treasuresInPlay,
  });

  const linkedTriggerEvents = triggerEvents.map(e => ({
    ...e,
    id: generateEventId(),
    causedBy: rootEventId,
  }));

  return {
    ok: true,
    events: [...baseEvents, ...coinEvents, ...linkedTriggerEvents],
  };
}

function handlePlayAllTreasures(
  state: GameState,
  player: PlayerId,
): CommandResult {
  const playerState = state.players[player];
  if (!playerState) {
    return { ok: false, error: "Player not found" };
  }

  if (state.phase !== "buy") {
    return { ok: false, error: "Not in buy phase" };
  }

  const treasures = playerState.hand.filter(isTreasureCard);
  if (treasures.length === 0) {
    return { ok: true, events: [] };
  }

  // Play treasures in hand order (triggers fire automatically)
  const { events } = treasures.reduce(
    (acc, card) => {
      const result = handlePlayTreasure(acc.currentState, player, card);
      if (!result.ok) return acc;
      return {
        events: [...acc.events, ...result.events],
        currentState: applyEvents(acc.currentState, result.events),
      };
    },
    { events: [] as GameEvent[], currentState: state },
  );

  return { ok: true, events };
}

function handleUnplayTreasure(
  state: GameState,
  player: PlayerId,
  card: CardName,
): CommandResult {
  if (state.phase !== "buy") {
    return { ok: false, error: "Not in buy phase" };
  }
  if (!isTreasureCard(card)) {
    return { ok: false, error: "Not a treasure card" };
  }

  const playerState = state.players[player];
  if (!playerState) {
    return { ok: false, error: "Player not found" };
  }
  if (!playerState.inPlay.includes(card)) {
    return { ok: false, error: "Card not in play" };
  }

  // Check if any purchases have been made this turn
  const hasMadePurchases = state.turnHistory.some(
    action => action.type === "buy_card",
  );
  if (hasMadePurchases) {
    return {
      ok: false,
      error: "Cannot unplay treasures after already made purchases",
    };
  }

  const builder = new EventBuilder();

  // Root cause event - returning the treasure to hand
  builder.add({
    type: "CARD_RETURNED_TO_HAND",
    player: player,
    card,
    from: "inPlay",
  });

  // Subtract coins
  const coins = CARDS[card].coins || 0;

  if (coins > 0) {
    builder.add({ type: "COINS_MODIFIED", delta: -coins });
  }

  // Reverse treasure triggers (e.g., remove Merchant bonus if unplaying Silver)
  const treasuresInPlay = playerState.inPlay.filter(c =>
    CARDS[c].types.includes("treasure"),
  );
  const wasFirstOfType = treasuresInPlay.filter(c => c === card).length === 1;

  const originalTriggerEvents = processTriggers(
    state,
    player,
    "treasure_played",
    {
      card,
      isFirstOfType: wasFirstOfType,
      treasuresInPlay,
    },
  );

  const reverseTriggerEvents = originalTriggerEvents.map(e => {
    if (e.type === "COINS_MODIFIED") {
      return { type: "COINS_MODIFIED" as const, delta: -e.delta };
    }
    return e;
  });

  builder.addAll(reverseTriggerEvents);

  return { ok: true, events: builder.build() };
}

function handleBuyCard(
  state: GameState,
  player: PlayerId,
  card: CardName,
): CommandResult {
  // Validate using middleware
  const validationError = validateCommand(
    () => validators.phase(state, "buy"),
    () => validators.hasBuys(state),
    () => validators.cardExists(card),
  );
  if (validationError) {
    return validationError;
  }

  // Calculate effective cost with modifiers
  const { modifiedCost, baseCost, modifiers } = calculateEffectiveCost(
    state,
    card,
  );

  // Validate cost and supply
  const costValidationError = validateCommand(
    () => validators.hasCoins(state, modifiedCost),
    () => validators.cardInSupply(state, card),
  );
  if (costValidationError) {
    return costValidationError;
  }

  const builder = new EventBuilder();

  // Root cause event - gaining the card
  builder.add({
    type: "CARD_GAINED",
    player: player,
    card,
    to: "discard",
  });

  // Emit cost modification event if cost was modified
  if (baseCost !== modifiedCost) {
    builder.add({
      type: "COST_MODIFIED",
      card,
      baseCost,
      modifiedCost,
      modifiers,
    });
  }

  builder.addAll([
    { type: "BUYS_MODIFIED", delta: -1 },
    { type: "COINS_MODIFIED", delta: -modifiedCost },
  ]);

  return { ok: true, events: builder.build() };
}

function handleEndPhase(state: GameState, player: PlayerId): CommandResult {
  if (state.phase === "action") {
    // Transition to buy phase
    const phaseEventId = generateEventId();
    return {
      ok: true,
      events: [
        {
          type: "PHASE_CHANGED",
          phase: "buy",
          id: phaseEventId,
        },
      ],
    };
  }

  if (state.phase === "buy") {
    // End turn - cleanup and start next player's turn
    const playerState = state.players[player];
    if (!playerState) {
      return { ok: false, error: "Player not found" };
    }

    // Root cause - ending turn (add explicit TURN_ENDED event)
    const endTurnId = generateEventId();
    const turnEndedEvent: GameEvent = {
      type: "TURN_ENDED",
      player: player,
      turn: state.turn,
      id: endTurnId,
    };

    // Discard hand and in-play cards (atomic events)
    const handDiscardEvents: GameEvent[] = playerState.hand.map(card => ({
      type: "CARD_DISCARDED" as const,
      player,
      card,
      from: "hand" as const,
      id: generateEventId(),
      causedBy: endTurnId,
    }));

    const inPlayDiscardEvents: GameEvent[] = playerState.inPlay.map(card => ({
      type: "CARD_DISCARDED" as const,
      player,
      card,
      from: "inPlay" as const,
      id: generateEventId(),
      causedBy: endTurnId,
    }));

    const cleanupEvents = [
      turnEndedEvent,
      ...handDiscardEvents,
      ...inPlayDiscardEvents,
    ];

    // Draw 5 new cards
    const drawEvents = createDrawEvents(
      player,
      applyEvents(state, cleanupEvents).players[player],
      GAME_CONSTANTS.INITIAL_HAND_SIZE,
    );

    const allEvents = [
      ...cleanupEvents,
      ...createResourceEvents(drawEvents, endTurnId),
    ];

    // Check game over
    const stateAfterDraw = applyEvents(state, allEvents);
    const gameOverEvent = checkGameOver(stateAfterDraw);
    if (gameOverEvent) {
      return {
        ok: true,
        events: [
          ...allEvents,
          {
            ...gameOverEvent,
            id: generateEventId(),
            causedBy: endTurnId,
          },
        ],
      };
    }

    // Start next turn - new root event (not caused by previous turn for log clarity)
    const nextPlayer = getNextPlayer(stateAfterDraw, player);
    const turnStartId = generateEventId();
    return {
      ok: true,
      events: [
        ...allEvents,
        {
          type: "TURN_STARTED",
          turn: state.turn + 1,
          player: nextPlayer,
          id: turnStartId,
        },
        ...createResourceEvents(
          [
            { type: "ACTIONS_MODIFIED", delta: 1 },
            { type: "BUYS_MODIFIED", delta: 1 },
          ],
          turnStartId,
        ),
      ],
    };
  }

  return { ok: true, events: [] };
}

function handleRequestUndo(
  _state: GameState,
  player: PlayerId,
  toEventId: string,
  reason?: string,
): CommandResult {
  const requestId = `undo_${Date.now()}_${Math.random().toString(GAME_CONSTANTS.UUID_BASE).slice(GAME_CONSTANTS.UUID_SLICE)}`;

  const builder = new EventBuilder();
  builder.add({
    type: "UNDO_REQUESTED",
    requestId,
    byPlayer: player,
    toEventId,
    reason,
  });

  return { ok: true, events: builder.build() };
}
