import type { GameState, CardName } from "../types/game-state";
import type { CommandResult } from "./types";
import type { GameEvent, PlayerId } from "../events/types";
import {
  CARDS,
  isTreasureCard,
  type TriggerType,
  type TriggerContext,
} from "../data/cards";
import { getCardEffect } from "../cards/base";
import { applyEvents } from "../events/apply";
import { generateEventId } from "../events/id-generator";
import { EventBuilder } from "../events/event-builder";
import { createResourceEvents } from "./handle-helpers";
import { validators, validateCommand } from "./validators";
import { orchestrateAttack } from "./attack-orchestration";

/**
 * Process triggers from cards in play for a given trigger type.
 * Returns events generated by matching triggers.
 */
function processTriggers(
  state: GameState,
  playerId: PlayerId,
  triggerType: TriggerType,
  context: TriggerContext,
) {
  const playerState = state.players[playerId];
  if (!playerState) return [];

  return playerState.inPlay.flatMap(inPlayCard => {
    const triggers = CARDS[inPlayCard].triggers;
    if (!triggers) return [];

    return triggers
      .filter(t => t.on === triggerType)
      .filter(t => !t.condition || t.condition(context))
      .flatMap(t => t.effect(context));
  });
}

export function handlePlayAction(
  state: GameState,
  playerId: PlayerId,
  card: CardName,
): CommandResult {
  // Validate using middleware
  const validationError = validateCommand(
    () => validators.phase(state, "action"),
    () => validators.hasActions(state),
    () => validators.noPendingDecision(state),
    () => validators.isAction(card),
    () => validators.playerExists(state, playerId),
    () => validators.cardInHand(state, playerId, card),
  );
  if (validationError) {
    return validationError;
  }

  // Root cause event - playing the card
  const rootEventId = generateEventId();
  const playerState = state.players[playerId];
  const sourceIndex = playerState.hand.indexOf(card);

  const baseEvents = [
    {
      type: "CARD_PLAYED" as const,
      playerId,
      card,
      sourceIndex,
      id: rootEventId,
    },
    ...createResourceEvents(
      [{ type: "ACTIONS_MODIFIED", delta: -1 }],
      rootEventId,
    ),
  ];

  // Apply these events to get intermediate state
  const midState = applyEvents(state, baseEvents);

  // Execute card effect
  const effect = getCardEffect(card);
  if (effect) {
    // Check if this is an attack card (auto-handle reactions)
    const cardDef = CARDS[card];
    const isAttackCard = cardDef?.types.includes("attack");

    if (isAttackCard) {
      // Delegate to centralized attack orchestration
      const attackEvents = orchestrateAttack({
        state: midState,
        attacker: playerId,
        attackCard: card,
        effect,
        rootEventId,
      });
      return { ok: true, events: [...baseEvents, ...attackEvents] };
    }

    // Not an attack card, call effect normally
    const result = effect({
      state: midState,
      playerId,
      card,
    });

    const linkedEffectEvents = result.events.map(e => ({
      ...e,
      id: generateEventId(),
      causedBy: rootEventId,
    }));

    // Handle normal decision if present
    const decisionEvent = result.pendingChoice
      ? [
          {
            type: "DECISION_REQUIRED" as const,
            decision: {
              ...result.pendingChoice,
              cardBeingPlayed: card,
              metadata: {
                ...result.pendingChoice.metadata,
                originalCause: rootEventId,
              },
            },
            id: generateEventId(),
            causedBy: rootEventId,
          },
        ]
      : [];

    return {
      ok: true,
      events: [...baseEvents, ...linkedEffectEvents, ...decisionEvent],
    };
  }

  return { ok: true, events: baseEvents };
}

export function handlePlayTreasure(
  state: GameState,
  playerId: PlayerId,
  card: CardName,
): CommandResult {
  // Validate using middleware
  const validationError = validateCommand(
    () => validators.phase(state, "buy"),
    () => validators.noPendingDecision(state),
    () => validators.isTreasure(card),
    () => validators.playerExists(state, playerId),
    () => validators.cardInHand(state, playerId, card),
  );
  if (validationError) {
    return validationError;
  }

  const playerState = state.players[playerId];
  const sourceIndex = playerState.hand.indexOf(card);

  // Root cause event - playing the treasure
  const rootEventId = generateEventId();
  const baseEvents = [
    {
      type: "CARD_PLAYED" as const,
      playerId,
      card,
      sourceIndex,
      id: rootEventId,
    },
  ];

  // Add coins - caused by playing the treasure
  const coins = CARDS[card].coins || 0;
  const coinEvents =
    coins > 0
      ? createResourceEvents(
          [{ type: "COINS_MODIFIED", delta: coins }],
          rootEventId,
        )
      : [];

  // Check for treasure triggers from cards in play
  const treasuresInPlay = playerState.inPlay.filter(c =>
    CARDS[c].types.includes("treasure"),
  );
  const isFirstOfType = !treasuresInPlay.includes(card);

  const triggerEvents = processTriggers(state, playerId, "treasure_played", {
    card,
    isFirstOfType,
    treasuresInPlay,
  });

  const linkedTriggerEvents = triggerEvents.map(e => ({
    ...e,
    id: generateEventId(),
    causedBy: rootEventId,
  }));

  return {
    ok: true,
    events: [...baseEvents, ...coinEvents, ...linkedTriggerEvents],
  };
}

export function handlePlayAllTreasures(
  state: GameState,
  playerId: PlayerId,
): CommandResult {
  const playerState = state.players[playerId];
  if (!playerState) {
    return { ok: false, error: "Player not found" };
  }

  if (state.phase !== "buy") {
    return { ok: false, error: "Not in buy phase" };
  }

  const treasures = playerState.hand.filter(isTreasureCard);
  if (treasures.length === 0) {
    return { ok: true, events: [] };
  }

  // Play treasures in hand order (triggers fire automatically)
  const { events } = treasures.reduce(
    (acc, card) => {
      const result = handlePlayTreasure(acc.currentState, playerId, card);
      if (!result.ok) return acc;
      return {
        events: [...acc.events, ...result.events],
        currentState: applyEvents(acc.currentState, result.events),
      };
    },
    { events: [] as GameEvent[], currentState: state },
  );

  return { ok: true, events };
}

export function handleUnplayTreasure(
  state: GameState,
  playerId: PlayerId,
  card: CardName,
): CommandResult {
  if (state.phase !== "buy") {
    return { ok: false, error: "Not in buy phase" };
  }
  if (!isTreasureCard(card)) {
    return { ok: false, error: "Not a treasure card" };
  }

  const playerState = state.players[playerId];
  if (!playerState) {
    return { ok: false, error: "Player not found" };
  }
  if (!playerState.inPlay.includes(card)) {
    return { ok: false, error: "Card not in play" };
  }

  // Check if any purchases have been made this turn
  const hasMadePurchases = state.turnHistory.some(
    action => action.type === "buy_card",
  );
  if (hasMadePurchases) {
    return {
      ok: false,
      error: "Cannot unplay treasures after already made purchases",
    };
  }

  const builder = new EventBuilder();

  // Root cause event - returning the treasure to hand
  builder.add({
    type: "CARD_RETURNED_TO_HAND",
    playerId,
    card,
    from: "inPlay",
  });

  // Subtract coins
  const coins = CARDS[card].coins || 0;

  if (coins > 0) {
    builder.add({ type: "COINS_MODIFIED", delta: -coins });
  }

  // Reverse treasure triggers (e.g., remove Merchant bonus if unplaying Silver)
  const treasuresInPlay = playerState.inPlay.filter(c =>
    CARDS[c].types.includes("treasure"),
  );
  const wasFirstOfType = treasuresInPlay.filter(c => c === card).length === 1;

  const originalTriggerEvents = processTriggers(
    state,
    playerId,
    "treasure_played",
    {
      card,
      isFirstOfType: wasFirstOfType,
      treasuresInPlay,
    },
  );

  const reverseTriggerEvents = originalTriggerEvents.map(e => {
    if (e.type === "COINS_MODIFIED") {
      return { type: "COINS_MODIFIED" as const, delta: -e.delta };
    }
    return e;
  });

  builder.addAll(reverseTriggerEvents);

  return { ok: true, events: builder.build() };
}

/**
 * Calculate the effective cost of a card considering active effects.
 * Returns base cost, modified cost, and list of applied modifiers.
 * @internal - Only used by command handler for affordability validation
 */
function calculateEffectiveCost(
  state: GameState,
  card: CardName,
): {
  baseCost: number;
  modifiedCost: number;
  modifiers: Array<{ source: CardName; delta: number }>;
} {
  const baseCost = CARDS[card].cost;
  const modifiers = state.activeEffects
    .filter(e => e.effectType === "cost_reduction")
    .map(e => ({ source: e.source, delta: -e.parameters.amount }));

  const modifiedCost = Math.max(
    0,
    baseCost + modifiers.reduce((sum, m) => sum + m.delta, 0),
  );

  return { baseCost, modifiedCost, modifiers };
}

export function handleBuyCard(
  state: GameState,
  playerId: PlayerId,
  card: CardName,
): CommandResult {
  // Validate using middleware
  const validationError = validateCommand(
    () => validators.phase(state, "buy"),
    () => validators.noPendingDecision(state),
    () => validators.hasBuys(state),
    () => validators.cardExists(card),
  );
  if (validationError) {
    return validationError;
  }

  // Calculate effective cost with modifiers
  const { modifiedCost, baseCost, modifiers } = calculateEffectiveCost(
    state,
    card,
  );

  // Validate cost and supply
  const costValidationError = validateCommand(
    () => validators.hasCoins(state, modifiedCost),
    () => validators.cardInSupply(state, card),
  );
  if (costValidationError) {
    return costValidationError;
  }

  const builder = new EventBuilder();

  // Root cause event - gaining the card
  builder.add({
    type: "CARD_GAINED",
    playerId,
    card,
    to: "discard",
  });

  // Emit cost modification event if cost was modified
  if (baseCost !== modifiedCost) {
    builder.add({
      type: "COST_MODIFIED",
      card,
      baseCost,
      modifiedCost,
      modifiers,
    });
  }

  builder.addAll([
    { type: "BUYS_MODIFIED", delta: -1 },
    { type: "COINS_MODIFIED", delta: -modifiedCost },
  ]);

  return { ok: true, events: builder.build() };
}
